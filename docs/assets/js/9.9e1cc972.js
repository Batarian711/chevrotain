(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{52:function(e,t,r){"use strict";r.r(t);var a=r(0),s=Object(a.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("div",{staticClass:"content"},[r("h1",{attrs:{id:"resolving-grammar-errors"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#resolving-grammar-errors","aria-hidden":"true"}},[e._v("#")]),e._v(" Resolving Grammar Errors")]),r("ul",[r("li",[r("a",{attrs:{href:"#COMMON_PREFIX"}},[e._v("Common Prefix Ambiguities.")])])]),r("h2",{attrs:{id:"COMMON_PREFIX"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#COMMON_PREFIX","aria-hidden":"true"}},[e._v("#")]),e._v(" Common Prefix Ambiguities")]),r("p",[e._v("Imagine the following grammar:")]),r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('myRule:\n  "A" "B" |\n  "A" "B" "C"\n')])]),r("p",[e._v('The first alternative is a prefix of the second alternative.\nNow lets consider the input ["A", "B"].\nFor this input the first alternative would be matched as expected.')]),r("p",[e._v('However for the input ["A", "B", "C"] the first\nalternative would still be matched but this time '),r("strong",[e._v("incorrectly")]),e._v("\nas alternation matches are attempted "),r("strong",[e._v("in order")]),e._v(".")]),r("p",[e._v("There are two ways to resolve this:")]),r("ul",[r("li",[r("p",[e._v("Reorder the alternatives so that shorter common prefix lookahead\npaths appears after the longer ones.")]),r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('myRule:\n  "A" "B" "C" |\n  "A" "B"\n')])])]),r("li",[r("p",[e._v("Refactor the grammar to extract common prefixes.")]),r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('  myRule:\n    "A" "B" ("C")?\n')])])])])])}],!1,null,null,null);t.default=s.exports}}]);